// Generated by CoffeeScript 1.12.6
var Connection, clone, http, is_object, krb5, url;

http = {
  http: require('http'),
  https: require('https')
};

url = require('url');

try {
  krb5 = require('krb5');
} catch (error1) {

}

clone = function(obj) {
  var key, newInstance;
  if ((obj == null) || typeof obj !== 'object') {
    return obj;
  }
  newInstance = new obj.constructor();
  for (key in obj) {
    newInstance[key] = clone(obj[key]);
  }
  return newInstance;
};

is_object = function(obj) {
  return (obj != null) && typeof obj === 'object';
};

Connection = function(client) {
  var options;
  this.client = client;
  options = clone(this.client.options);
  options.protocol = options.protocol + ":";
  options.hostname = options.host;
  options.path = options.path != null ? options.path.replace(/\/$/, "") : "";
  options.headers = is_object(options.headers) ? options.headers : {};
  options.headers['content-type'] = 'application/json';
  options.headers['Accept'] = 'application/json';
  options.rejectUnauthorized = false;
  this.options = options;
  return this;
};

Connection.prototype.makeRequest = function(method, command, data, callback) {
  var do_krb5, do_request, do_spnego, options;
  options = clone(this.options);
  options.method = method;
  options.path = options.path + command;
  do_krb5 = (function(_this) {
    return function() {
      var base;
      if (_this.client.krb5) {
        return do_spnego();
      }
      if (!_this.client.options.krb5.principal) {
        return do_request();
      }
      if ((base = _this.client.options.krb5).service_principal == null) {
        base.service_principal = "HTTP@" + options.hostname;
      }
      if (!krb5) {
        return callback(Error("Module 'krb5' not installed"));
      }
      return krb5(_this.client.options.krb5, function(err, k) {
        if (err) {
          return callback(err);
        }
        _this.client.krb5 = k;
        return do_spnego();
      });
    };
  })(this);
  do_spnego = (function(_this) {
    return function() {
      return _this.client.krb5.token(function(err, token) {
        if (err) {
          return callback(err);
        }
        options.headers['Authorization'] = 'Negotiate ' + token;
        return do_request();
      });
    };
  })(this);
  do_request = (function(_this) {
    return function() {
      var req;
      req = http[_this.client.options.protocol].request(options, function(res) {
        var body;
        body = '';
        res.on('data', function(chunk) {
          return body += chunk;
        });
        res.on('end', function() {
          var e, error;
          error = null;
          try {
            body = _this.handleJson(res, body);
          } catch (error1) {
            e = error1;
            body = null;
            error = e;
          }
          return callback(error, body, res);
        });
        return res.on('close', function() {
          var e;
          e = new Error('Connection closed');
          return callback(e, null);
        });
      });
      req.on('error', function(err) {
        return callback(err);
      });
      if (data && data !== '') {
        data = typeof data === 'string' ? data : JSON.stringify(data);
        req.write(data, 'utf8');
      }
      return req.end();
    };
  })(this);
  return do_krb5();
};

Connection.prototype.get = function(command, callback) {
  return this.makeRequest('GET', command, '', callback);
};

Connection.prototype.put = function(command, data, callback) {
  return this.makeRequest('PUT', command, data, callback);
};

Connection.prototype.post = function(command, data, callback) {
  return this.makeRequest('POST', command, data, callback);
};

Connection.prototype["delete"] = function(command, callback) {
  return this.makeRequest('DELETE', command, '', callback);
};

Connection.prototype.handleJson = function(response, body) {
  var e;
  switch (response.statusCode) {
    case 201:
    case 200:
      if (body) {
        return JSON.parse(body);
      } else {
        return null;
      }
    default:
      e = new Error(response.statusCode + ": " + this.codes[response.statusCode]);
      e.code = response.statusCode;
      e.body = body;
      throw e;
  }
};

Connection.prototype.codes = {
  100: 'Continue',
  101: 'Switching Protocols',
  102: 'Processing (WebDAV)',
  200: 'OK',
  201: 'Created',
  202: 'Accepted',
  203: 'Non-Authoritative Information',
  204: 'No Content',
  205: 'Reset Content',
  206: 'Partial Content',
  207: 'Multi-Status (WebDAV)',
  300: 'Multiple Choices',
  301: 'Moved Permanently',
  302: 'Found',
  303: 'See Other',
  304: 'Not Modified',
  305: 'Use Proxy',
  306: 'Switch Proxy',
  307: 'Temporary Redirect',
  400: 'Bad Request',
  401: 'Unauthorized',
  402: 'Payment Required',
  403: 'Forbidden',
  404: 'Not Found',
  405: 'Method Not Allowed',
  406: 'Not Acceptable',
  407: 'Proxy Authentication Required',
  408: 'Request Timeout',
  409: 'Conflict',
  410: 'Gone',
  411: 'Length Required',
  412: 'Precondition Failed',
  413: 'Request Entity Too Large',
  414: 'Request-URI Too Long',
  415: 'Unsupported Media Type',
  416: 'Requested Range Not Satisfiable',
  417: 'Expectation Failed',
  418: 'I\'m a teapot',
  422: 'Unprocessable Entity (WebDAV)',
  423: 'Locked (WebDAV)',
  424: 'Failed Dependency (WebDAV)',
  425: 'Unordered Collection',
  426: 'Upgrade Required',
  449: 'Retry With',
  500: 'Internal Server Error',
  501: 'Not Implemented',
  502: 'Bad Gateway',
  503: 'Service Unavailable',
  504: 'Gateway Timeout',
  505: 'HTTP Version Not Supported',
  506: 'Variant Also Negotiates',
  507: 'Insufficient Storage (WebDAV)',
  509: 'Bandwidth Limit Exceeded (Apache bw/limited extension)',
  510: 'Not Extended'
};

module.exports = Connection;
