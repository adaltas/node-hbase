// Generated by CoffeeScript 2.3.2
// # Connection: HTTP REST requests for HBase

// The connection object handles HTTP requests. You shouldn't have to call it
// directly because HBase requests are transparently made by the client objects.

// Note, at this point, the HTTP client only communicate to HBase with the JSON
// format. Some valid requests requests return an empty body which of course not a
// valid JSON. In such cases, no error is thrown by the response handler but the
// returned value is null.

// ## Dependencies
var Connection, clone, http, is_object, krb5, url;

http = {
  http: require('http'),
  https: require('https')
};

url = require('url');

try {
  krb5 = require('krb5'); // No Kerberos Support
} catch (error1) {

}


// ## Utilities

// Based on https://coffeescript-cookbook.github.io/chapters/classes_and_objects/cloning
clone = function (obj) {
  var key, newInstance;
  if ((obj == null) || typeof obj !== 'object') {
    return obj;
  }
  newInstance = new obj.constructor();
  for (key in obj) {
    newInstance[key] = clone(obj[key]);
  }
  return newInstance;
};

is_object = function (obj) {
  return (obj != null) && typeof obj === 'object';
};

// ## Constructor
Connection = function (client) {
  var options;
  this.client = client;
  options = clone(this.client.options);
  options.protocol = `${options.protocol}:`;
  options.hostname = options.host;
  options.path = options.path != null ? options.path.replace(/\/$/, "") : "";
  options.headers = is_object(options.headers) ? options.headers : {};
  options.headers['content-type'] = 'application/json';
  options.headers['Accept'] = 'application/json';
  options.rejectUnauthorized = false;
  this.options = options;
  return this;
};

Connection.prototype.makeRequest = function (method, command, data, callback) {
  var do_async, do_krb5, do_request, do_spnego, do_token, options;
  options = clone(this.options);
  options.method = method;
  options.path = options.path + command;
  do_async = () => {
    // Ensure events registered after connection are received
    return setImmediate(do_krb5);
  };
  do_krb5 = () => {
    var base;
    if (this.client.krb5) {
      return do_spnego();
    }
    if (!this.client.options.krb5.principal) {
      return do_request();
    }
    if ((base = this.client.options.krb5).service_principal == null) {
      base.service_principal = `HTTP@${options.hostname}`;
    }
    if (!krb5) {
      return callback(Error("Module 'krb5' not installed"));
    }
    return do_spnego();
  };
  do_spnego = () => {
    if (!(this.client.options.krb5.password || this.client.options.krb5.keytab)) {
      return do_token();
    }
    // Kinit first if password or keytab provided
    return krb5.kinit(this.client.options.krb5, function (err, ccname) {
      if (err) {
        return callback(Error(err));
      }
      return do_token();
    });
  };
  do_token = () => {
    return krb5.spnego(this.client.options.krb5, function (err, token) {
      var e;
      e = 'GSS error ' + err;
      if (err) {
        return callback(Error(e));
      }
      options.headers['Authorization'] = 'Negotiate ' + token;
      return do_request();
    });
  };
  do_request = () => {
    var req;
    this.client.emit('request', {
      options: options,
      data: data
    });
    req = http[this.client.options.protocol].request(options, (res) => {
      var body;
      body = '';
      res.on('data', function (chunk) {
        return body += chunk;
      });
      res.on('end', () => {
        var e, error;
        error = null;
        try {
          body = this.handleJson(res, body);
        } catch (error1) {
          e = error1;
          body = null;
          error = e;
        }
        return callback(error, body, res);
      });
      return res.on('error', function (err) {
        return callback(err);
      });
    });
    req.on('error', function (err) {
      return callback(err);
    });
    if (data && data !== '') {
      data = typeof data === 'string' ? data : JSON.stringify(data);
      req.write(data, 'utf8');
    }
    // Handle Timeout
    if (options.timeout) {
      req.setTimeout(options.timeout, function () {
        return req.abort();
      });
    }
    // Terminate Request
    return req.end();
  };
  return do_async();
};

Connection.prototype.get = function (command, callback) {
  return this.makeRequest('GET', command, '', callback);
};

Connection.prototype.put = function (command, data, callback) {
  return this.makeRequest('PUT', command, data, callback);
};

Connection.prototype.post = function (command, data, callback) {
  return this.makeRequest('POST', command, data, callback);
};

Connection.prototype.delete = function (command, callback) {
  return this.makeRequest('DELETE', command, '', callback);
};

Connection.prototype.handleJson = function (response, body) {
  var e;
  switch (response.statusCode) {
    // Created
    case 201:
    case 200: // Ok
      if (body) {
        return JSON.parse(body);
      } else {
        return null;
      }
    default:
      e = new Error(`${response.statusCode}: ${this.codes[response.statusCode]}`);
      e.code = response.statusCode;
      e.body = body;
      throw e;
  }
};

Connection.prototype.codes = {
  100: 'Continue',
  101: 'Switching Protocols',
  102: 'Processing (WebDAV)',
  200: 'OK',
  201: 'Created',
  202: 'Accepted',
  203: 'Non-Authoritative Information',
  204: 'No Content',
  205: 'Reset Content',
  206: 'Partial Content',
  207: 'Multi-Status (WebDAV)',
  300: 'Multiple Choices',
  301: 'Moved Permanently',
  302: 'Found',
  303: 'See Other',
  304: 'Not Modified',
  305: 'Use Proxy',
  306: 'Switch Proxy',
  307: 'Temporary Redirect',
  400: 'Bad Request',
  401: 'Unauthorized',
  402: 'Payment Required',
  403: 'Forbidden',
  404: 'Not Found',
  405: 'Method Not Allowed',
  406: 'Not Acceptable',
  407: 'Proxy Authentication Required',
  408: 'Request Timeout',
  409: 'Conflict',
  410: 'Gone',
  411: 'Length Required',
  412: 'Precondition Failed',
  413: 'Request Entity Too Large',
  414: 'Request-URI Too Long',
  415: 'Unsupported Media Type',
  416: 'Requested Range Not Satisfiable',
  417: 'Expectation Failed',
  418: 'I\'m a teapot',
  422: 'Unprocessable Entity (WebDAV)',
  423: 'Locked (WebDAV)',
  424: 'Failed Dependency (WebDAV)',
  425: 'Unordered Collection',
  426: 'Upgrade Required',
  449: 'Retry With',
  500: 'Internal Server Error',
  501: 'Not Implemented',
  502: 'Bad Gateway',
  503: 'Service Unavailable',
  504: 'Gateway Timeout',
  505: 'HTTP Version Not Supported',
  506: 'Variant Also Negotiates',
  507: 'Insufficient Storage (WebDAV)',
  509: 'Bandwidth Limit Exceeded (Apache bw/limited extension)',
  510: 'Not Extended'
};

Connection.prototype.kdestroy = function (options, callback) {
  return krb5.kdestroy(options, callback)
}

module.exports = Connection;
