// Generated by CoffeeScript 2.0.1
var crypto, utils;

crypto = require('crypto');

utils = {
  base64: {
    encode: function(data, to_encoding) {
      if (to_encoding === 'base64') {
        return data;
      }
      if (!Buffer.isBuffer(data)) {
        data = new Buffer(data, to_encoding || 'utf8');
      }
      return data.toString('base64');
    },
    decode: function(data, from_encoding) {
      if (from_encoding === 'base64') {
        return data;
      }
      if (!Buffer.isBuffer(data)) {
        data = new Buffer(data, 'base64');
      }
      return data.toString(from_encoding || 'utf8');
    }
  },
  url: {
    /*
    Arguments:
    *   `table`
    *   `key`
    *   `columns`
    *   `start`
    *   `end`
    *   `params`
     */
    encode: function(args) {
      var columnPath, cs, k, namespace, newpath, nsSep, ps, ref, ref1, tablename, v;
      if (!args.table) {
        throw new Error('Missing parameters "table"');
      }
      newpath = '/';
      // params = args.pop() if args.length > 3 and typeof args[args.length - 1] is 'object'
      // Table
      nsSep = args.table.indexOf(':');
      if (nsSep >= 0) {
        namespace = args.table.substr(0, nsSep);
        tablename = args.table.substr(nsSep + 1);
        newpath += encodeURIComponent(namespace) + ':' + encodeURIComponent(tablename);
      } else {
        newpath += encodeURIComponent(args.table);
      }
      // Key
      if (args.key) {
        newpath += '/';
        newpath += encodeURIComponent(args.key);
      }
      // Columns
      if (args.columns) {
        columnPath = void 0;
        if (Array.isArray(args.columns)) {
          columnPath = args.columns.map(function(column) {
            if (Array.isArray(column)) {
              return column.map(function(c) {
                return encodeURIComponent(c);
              }).join(':');
            } else {
              return encodeURIComponent(column);
            }
          }).join(',');
        } else if (typeof args.columns === 'object') {
          cs = [];
          ref = args.columns;
          for (k in ref) {
            v = ref[k];
            cs.push(`${encodeURIComponent(k)}:${encodeURIComponent(v)}`);
          }
          columnPath = cs.join(',');
        } else {
          columnPath = args.columns ? encodeURIComponent(args.columns) : '';
        }
        if (columnPath) {
          newpath += "/";
        }
        if (columnPath) {
          newpath += `${columnPath}`;
        }
      }
      // From & To
      if (args.end) {
        newpath += '/';
        if (args.start) {
          newpath += encodeURIComponent(args.start);
          newpath += ',';
        }
        newpath += encodeURIComponent(args.end);
      }
      // Params
      if (args.params) {
        newpath += '?';
        ps = [];
        ref1 = args.params;
        for (k in ref1) {
          v = ref1[k];
          ps.push(`${encodeURIComponent(k)}=${encodeURIComponent(v)}`);
        }
        newpath += ps.join(',');
      }
      return newpath;
    }
  },
  merge: function() {
    var clone, copy, from, i, inverse, j, name, options, ref, ref1, src, target, to;
    target = arguments[0];
    from = 1;
    to = arguments.length;
    if (typeof target === 'boolean') {
      inverse = !!target;
      target = arguments[1];
      from = 2;
    }
    // Handle case when target is a string or something (possible in deep copy)
    if (typeof target !== "object" && typeof target !== 'function') {
      target = {};
    }
    for (i = j = ref = from, ref1 = to; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) !== null) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            // Prevent never-ending loop
            continue;
          }
          // Recurse if we're merging plain objects
          if ((copy != null) && typeof copy === 'object' && !Array.isArray(copy) && !(copy instanceof RegExp)) {
            clone = src && (src && typeof src === 'object' ? src : {});
            // Never move original objects, clone them
            target[name] = utils.merge(false, clone, copy);
          // Don't bring in undefined values
          } else if (copy !== void 0) {
            if (!(inverse && typeof target[name] !== 'undefined')) {
              target[name] = copy;
            }
          }
        }
      }
    }
    // Return the modified object
    return target;
  }
};

module.exports = utils;
