// Generated by CoffeeScript 2.3.2
// # Table operations: create, modify and delete HBase tables

// ## Dependencies
var Row, Scanner, Table;

Row = require('./row');

Scanner = require('./scanner');

// ## Constructor
Table = function(client, name) {
  this.client = client;
  this.name = name;
  return this;
};

// ## `table.create`

// Create a new table in HBase
Table.prototype.create = function(schema, callback) {
  var args;
  args = Array.prototype.slice.call(arguments);
  schema = args.length && typeof args[0] === 'object' || typeof args[0] === 'string' ? args.shift() : {};
  callback = args.length ? args.shift() : null;
  schema.name = this.name;
  if (typeof schema === 'string') {
    schema = {
      ColumnSchema: [
        {
          name: schema
        }
      ]
    };
  }
  return this.client.connection.put(`/${this.name}/schema`, schema, (error, data) => {
    if (!callback) {
      if (error) {
        throw error;
      } else {
        return;
      }
    }
    return callback.apply(this, [error, error ? null : true]);
  });
};

// ## `table.delete`

// Drop an existing table.
Table.prototype.delete = function(callback) {
  return this.client.connection.delete(`/${this.name}/schema`, (error, data) => {
    if (!callback) {
      if (error) {
        throw error;
      } else {
        return;
      }
    }
    return callback.apply(this, [error, error ? null : true]);
  });
};

// ## `table.exists`

// Check if a table is created.

// ```javascript
// myTable.exists(calblack);
// ```
Table.prototype.exists = function(callback) {
  return this.client.connection.get(`/${this.name}/exists`, (error, exists) => {
    if (error && error.code === 404) {
      error = null;
      exists = false;
    }
    return callback.apply(this, [error, error ? null : exists !== false]);
  });
};

// ## Update an existing table

// NOT YET WORKING, waiting for [HBASE-3140](https://issues.apache.org/jira/browse/HBASE-3140).
Table.prototype.update = function(schema, callback) {
  schema.name = this.name;
  return this.client.connection.post(`/${this.name}/schema`, schema, (error, data) => {
    if (!callback) {
      if (error) {
        throw error;
      } else {
        return;
      }
    }
    return callback.apply(this, [error, error ? null : true]);
  });
};

// ## `table.schema`

// Retrieves table schema.
Table.prototype.schema = function(callback) {
  return this.client.connection.get(`/${this.name}/schema`, (error, data) => {
    return callback.apply(this, [error, error ? null : data]);
  });
};

// ## `table.regions`

// Retrieves table region metadata.
Table.prototype.regions = function(callback) {
  return this.client.connection.get(`/${this.name}/regions`, (error, data) => {
    return callback.apply(this, [error, error ? null : data]);
  });
};

// ## `table.row`

// Return a new row instance.
Table.prototype.row = function(key) {
  return new Row(this.client, this.name, key);
};

// ## `table.scan`

// Return a new scanner instance.
Table.prototype.scan = function(options, callback) {
  var chunks, scanner;
  if (arguments.length === 0) {
    options = {};
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      callback = options;
      options = {};
    }
  } else if (arguments.length !== 2) {
    throw Error('Invalid arguments');
  }
  options.table = this.name;
  scanner = new Scanner(this.client, options);
  if (callback) {
    chunks = [];
    scanner.on('readable', function() {
      var chunk, results;
      results = [];
      while (chunk = scanner.read()) {
        results.push(chunks.push(chunk));
      }
      return results;
    });
    scanner.on('error', function(err) {
      return callback(err);
    });
    scanner.on('end', function() {
      return callback(null, chunks);
    });
  }
  return scanner;
};

module.exports = Table;
