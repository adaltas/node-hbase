// Generated by CoffeeScript 1.8.0
var Row, Scanner, Table;

Row = require('./row');

Scanner = require('./scanner');


/*
Table operations: create, modify and delete HBase tables
========================================================

Grab an instance of "hbase.Table"
---------------------------------

```javascript
var myTable = hbase({}).getTable('my_table');
```

Or

```javascript
var client = new hbase.Client({});
var myTable = new hbase.Table(client, 'my_table');
```
 */

Table = function(client, name) {
  this.client = client;
  this.name = name;
  return this;
};


/*
Create a new table in HBase
---------------------------

```javascript
myTable.create(callback)
```

Callback is optionnal and receive two arguments, an 
error object if any and a boolean indicating whether 
the table was created or not.

The simplest way is to grab a table object and call 
its `create` function with the schema as argument.

```javascript
hbase()
.getTable('my_new_table')
.create('my_new_column', function(error, success){
  console.log('Table created: ' + (success ? 'yes' : 'no'));
} );
```

For more control on the table and column family schema
 configuration, the argument may be a full schema object. 
 It doesn't need to contain the "name" property as it will 
 be injected but may  contain the keys "is_meta" and "is_root" 
 as well as the column family schemas. The column property 
 must contain the key "name" and any other valid keys 
 ("blocksize", "bloomfilter", "blockcache", "compression", 
 "length", "versions", "ttl" and "in_memory").

```javascript
hbase()
.getTable( 'my_new_table' )
.create( {
  IS_META: false,
  IS_ROOT: false,
  COLUMNS: [{
    NAME: 'my_new_column'
  }]
}, function( error, success ){
  console.log('Table created: ' + (success ? 'yes' : 'no'));
} );
```
 */

Table.prototype.create = function(schema, callback) {
  var args;
  args = Array.prototype.slice.call(arguments);
  schema = args.length && typeof args[0] === 'object' || typeof args[0] === 'string' ? args.shift() : {};
  callback = args.length ? args.shift() : null;
  schema.name = this.name;
  if (typeof schema === 'string') {
    schema = {
      ColumnSchema: [
        {
          name: schema
        }
      ]
    };
  }
  return this.client.connection.put("/" + this.name + "/schema", schema, (function(_this) {
    return function(error, data) {
      if (!callback) {
        if (error) {
          throw error;
        } else {
          return;
        }
      }
      return callback.apply(_this, [error, error ? null : true]);
    };
  })(this));
};


/*
Drop an existing table
----------------------

```javascript
myTable.delete(callback);
```

Callback is optionnal and receive two arguments, an error object if any and a boolean indicating whether the table was removed/disabled or not.

```javascript
hbase()
.getTable('my_table')
.delete(function(error, success){
  assert.ok(success);
});
```
 */

Table.prototype["delete"] = function(callback) {
  return this.client.connection["delete"]("/" + this.name + "/schema", (function(_this) {
    return function(error, data) {
      if (!callback) {
        if (error) {
          throw error;
        } else {
          return;
        }
      }
      return callback.apply(_this, [error, error ? null : true]);
    };
  })(this));
};


/*
Check if a table is created
---------------------------

```javascript
myTable.exists(calblack);
```
 */

Table.prototype.exists = function(callback) {
  return this.client.connection.get("/" + this.name + "/exists", (function(_this) {
    return function(error, exists) {
      if (error && error.code === 404) {
        error = null;
        exists = false;
      }
      return callback.apply(_this, [error, error ? null : exists !== false]);
    };
  })(this));
};


/*
Update an existing table
------------------------

NOT YET WORKING, waiting for [HBASE-3140](https://issues.apache.org/jira/browse/HBASE-3140).
 */

Table.prototype.update = function(schema, callback) {
  schema.name = this.name;
  return this.client.connection.post("/" + this.name + "/schema", schema, (function(_this) {
    return function(error, data) {
      if (!callback) {
        if (error) {
          throw error;
        } else {
          return;
        }
      }
      return callback.apply(_this, [error, error ? null : true]);
    };
  })(this));
};


/*
Retrieves table schema
----------------------

```javascript
hbase()
.getTable( 'my_new_table' )
.getSchema(function(error, schema){
  console.log(schema);
});
```

Will print something similar to:

```json
{ name: 'node_hbase'
, IS_META: 'false'
, IS_ROOT: 'false'
, ColumnSchema:
   [ { name: 'column_2'
   , BLOCKSIZE: '65536'
   , BLOOMFILTER: 'NONE'
   , BLOCKCACHE: 'true'
   , COMPRESSION: 'NONE'
   , VERSIONS: '3'
   , REPLICATION_SCOPE: '0'
   , TTL: '2147483647'
   , IN_MEMORY: 'false'
   }
   ]
}
```
 */

Table.prototype.getSchema = function(callback) {
  return this.client.connection.get("/" + this.name + "/schema", (function(_this) {
    return function(error, data) {
      return callback.apply(_this, [error, error ? null : data]);
    };
  })(this));
};


/*
Retrieves table region metadata
-------------------------------

```javascript
hbase()
.getTable( 'my_new_table' )
.getRegions(function(error, regions){
  console.log(regions);
});
```

Will print something similar to:

```json
{ name: 'node_hbase'
, Region: 
   [ { startKey: ''
   , name: 'node_hbase,,1285801694075'
   , location: 'eha.home:56243'
   , id: 1285801694075
   , endKey: ''
   }
   ]
}
```
 */

Table.prototype.getRegions = function(callback) {
  return this.client.connection.get("/" + this.name + "/regions", (function(_this) {
    return function(error, data) {
      return callback.apply(_this, [error, error ? null : data]);
    };
  })(this));
};


/*
Return a new row instance
-----------------

```javascript
Table.getRow(key)
```
 */

Table.prototype.getRow = function(key) {
  return new Row(this.client, this.name, key);
};


/*
Return a new scanner instance
---------------------

```javascript
Table.scan(options, callback)
```
 */

Table.prototype.scan = function(options, callback) {
  var chunks, scanner;
  if (arguments.length === 0) {
    options = {};
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      callback = options;
      options = {};
    }
  } else if (arguments.length !== 2) {
    throw Error('Invalid arguments');
  }
  options.table = this.name;
  scanner = new Scanner(this.client, options);
  if (callback) {
    chunks = [];
    scanner.on('readable', function() {
      var chunk, _results;
      _results = [];
      while (chunk = scanner.read()) {
        _results.push(chunks.push(chunk));
      }
      return _results;
    });
    scanner.on('error', function(err) {
      return callback(err);
    });
    scanner.on('end', function() {
      return callback(null, chunks);
    });
  }
  return scanner;
};

module.exports = Table;
