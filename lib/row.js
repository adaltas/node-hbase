// Generated by CoffeeScript 1.8.0
var Row, Table, utils;

utils = require('./utils');

Table = require('./table');

Row = function(client, table, key) {
  this.client = client;
  this.table = (typeof table === "string" ? table : table.name);
  this.key = key;
  return this;
};

Row.prototype.get = function(column, callback) {
  var args, columns, end, isGlob, key, options, params, start, url;
  args = Array.prototype.slice.call(arguments);
  key = "/" + this.table + "/" + this.key;
  isGlob = this.key.substr(-1, 1) === "*";
  options = {};
  columns = null;
  start = null;
  end = null;
  params = {};
  if (typeof args[0] === "string" || (typeof args[0] === "object" && args[0] instanceof Array)) {
    columns = args.shift();
  }
  if (typeof args[0] === "object") {
    options = args.shift();
  }
  if (options.start) {
    start = options.start;
  }
  if (options.end) {
    end = options.end;
  }
  if (options.v) {
    params.v = options.v;
  }
  url = utils.url.encode({
    table: this.table,
    key: this.key,
    columns: columns,
    start: start,
    end: end,
    params: params
  });
  return this.client.connection.get(url, (function(_this) {
    return function(error, data) {
      var cells;
      if (error) {
        return args[0].apply(_this, [error, null]);
      }
      cells = [];
      data.Row.forEach(function(row) {
        key = utils.base64.decode(row.key, _this.client.options.encoding);
        return row.Cell.forEach(function(cell) {
          data = {};
          if (isGlob) {
            data.key = key;
          }
          data.column = utils.base64.decode(cell.column, _this.client.options.encoding);
          data.timestamp = cell.timestamp;
          data.$ = utils.base64.decode(cell.$, _this.client.options.encoding);
          return cells.push(data);
        });
      });
      return args[0].apply(_this, [null, cells]);
    };
  })(this));
};

Row.prototype.put = function(columns, values, callback) {
  var args, body, bodyCell, bodyRow, cell, cells, cellsKeys, data, k, k1, timestamps, url;
  args = Array.prototype.slice.call(arguments);
  url = void 0;
  body = void 0;
  bodyRow = void 0;
  if (args.length > 2) {
    columns = args.shift();
    values = args.shift();
    timestamps = void 0;
    if (typeof args[0] !== "function") {
      timestamps = args.shift();
    }
    callback = args.shift();
    if (typeof columns === "string") {
      columns = [columns];
      values = [values];
    } else {
      if (columns.length !== values.length) {
        throw new Error("Columns count must match values count");
      }
    }
    body = {
      Row: []
    };
    bodyRow = {
      key: utils.base64.encode(this.key, this.client.options.encoding),
      Cell: []
    };
    columns.forEach((function(_this) {
      return function(column, i) {
        var bodyCell;
        bodyCell = {};
        if (timestamps) {
          bodyCell.timestamp = timestamps[i];
        }
        bodyCell.column = utils.base64.encode(column, _this.client.options.encoding);
        bodyCell.$ = utils.base64.encode(values[i], _this.client.options.encoding);
        return bodyRow.Cell.push(bodyCell);
      };
    })(this));
    body.Row.push(bodyRow);
    url = utils.url.encode({
      table: this.table,
      key: this.key || "___false-row-key___",
      columns: columns
    });
  } else {
    data = args.shift();
    callback = args.shift();
    body = {
      Row: []
    };
    cellsKeys = {};
    data.forEach((function(_this) {
      return function(d) {
        var key;
        key = d.key || _this.key;
        if (!(key in cellsKeys)) {
          cellsKeys[key] = [];
        }
        return cellsKeys[key].push(d);
      };
    })(this));
    for (k in cellsKeys) {
      cells = cellsKeys[k];
      bodyRow = {
        key: utils.base64.encode(k, this.client.options.encoding),
        Cell: []
      };
      for (k1 in cells) {
        cell = cells[k1];
        bodyCell = {};
        if (cell.timestamp) {
          bodyCell.timestamp = "" + cell.timestamp;
        }
        bodyCell.column = utils.base64.encode(cell.column, this.client.options.encoding);
        bodyCell.$ = utils.base64.encode(cell.$, this.client.options.encoding);
        bodyRow.Cell.push(bodyCell);
      }
      body.Row.push(bodyRow);
    }
    url = utils.url.encode({
      table: this.table,
      key: this.key || "___false-row-key___",
      columns: ['test:']
    });
  }
  return this.client.connection.put(url, body, (function(_this) {
    return function(error, data) {
      if (!callback) {
        return;
      }
      return callback.apply(_this, [error, (error ? null : true)]);
    };
  })(this));
};

Row.prototype.exists = function(column, callback) {
  var args, url;
  args = Array.prototype.slice.call(arguments);
  column = (typeof args[0] === "string" ? args.shift() : null);
  url = utils.url.encode({
    table: this.table,
    key: this.key,
    columns: column
  });
  return this.client.connection.get(url, (function(_this) {
    return function(error, exists) {
      if (error && (error.code === 404 || error.code === 503)) {
        error = null;
        exists = false;
      }
      return args[0].apply(_this, [error, (error ? null : (exists === false ? false : true))]);
    };
  })(this));
};

Row.prototype["delete"] = function() {
  var args, columns, url;
  args = Array.prototype.slice.call(arguments);
  columns = void 0;
  if (typeof args[0] === "string" || (typeof args[0] === "object" && args[0] instanceof Array)) {
    columns = args.shift();
  }
  url = utils.url.encode({
    table: this.table,
    key: this.key,
    columns: columns
  });
  return this.client.connection["delete"](url, ((function(_this) {
    return function(error, success) {
      return args[0].apply(_this, [error, (error ? null : true)]);
    };
  })(this)), true);
};

module.exports = Row;
