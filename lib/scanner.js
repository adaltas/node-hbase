// Generated by CoffeeScript 2.3.2
// # Scanner operations

// Scanner are the most efficient way to retrieve multiple 
// rows and columns from HBase. Internally, it implements the native 
// [Node.js Stream Readable API]().

// ## Dependencies
var Readable, Scanner, Table, util, utils;

util = require('util');

utils = require('./utils');

Table = require('./table');

({Readable} = require('stream'));

// ## Constructor
Scanner = function(client, options = {}) {
  var base;
  this.options = options;
  this.options.objectMode = true;
  Readable.call(this, this.options);
  this.client = client;
  this.fetching = false;
  this.initializing = false;
  if (typeof this.options === 'string') {
    // @table = if typeof table is 'string' then table else table.name
    // @id = id or null
    this.options = {
      table: this.options
    };
  }
  if ((base = this.options).batch == null) {
    base.batch = 1000;
  }
  if (!this.options.table) {
    throw Error('Missing required option "table"');
  }
  this.options.id = null;
  return this.callback = null;
};

util.inherits(Scanner, Readable);

// ## `scanner.init(callback)`

// Internal method to create a new scanner and retrieve its ID.
Scanner.prototype.init = function(callback) {
  var encode, encoding, key, params;
  // options = utils.merge {}, @options
  params = {};
  if (params.batch == null) {
    params.batch = this.options.batch;
  }
  key = `/${this.options.table}/scanner`;
  encoding = this.options.encoding === 'undefined' ? this.options.encoding : this.client.options.encoding;
  if (this.options.startRow) {
    params.startRow = utils.base64.encode(this.options.startRow, encoding);
  }
  if (this.options.endRow) {
    params.endRow = utils.base64.encode(this.options.endRow, encoding);
  }
  if (this.options.startTime) {
    params.startTime = this.options.startTime;
  }
  if (this.options.endTime) {
    params.endTime = this.options.endTime;
  }
  if (this.options.maxVersions) {
    params.maxVersions = this.options.maxVersions;
  }
  if (this.options.column) {
    params.column = [];
    if (typeof this.options.column === 'string') {
      this.options.column = [this.options.column];
    }
    this.options.column.forEach(function(column, i) {
      return params.column[i] = utils.base64.encode(column, encoding);
    });
  }
  if (this.options.filter) {
    encode = function(obj) {
      var k, results;
      results = [];
      for (k in obj) {
        if (k === 'value' && (!obj['type'] || obj['type'] !== 'RegexStringComparator' && obj['type'] !== 'PageFilter')) {
          results.push(obj[k] = utils.base64.encode(obj[k], encoding));
        } else {
          if (typeof obj[k] === 'object') {
            results.push(encode(obj[k]));
          } else {
            results.push(void 0);
          }
        }
      }
      return results;
    };
    encode(this.options.filter);
    params.filter = JSON.stringify(this.options.filter);
  }
  return this.client.connection.put(key, params, (err, data, response) => {
    var id;
    if (err) {
      return callback(err);
    }
    id = /scanner\/(\w+)$/.exec(response.headers.location)[1];
    this.options.id = id;
    return callback(null, id);
  });
};

// ## `scanner.get(callback)`

// Internal method to retrieve a batch of records.
Scanner.prototype.get = function(callback) {
  var key;
  key = `/${this.options.table}/scanner/${this.options.id}`;
  return this.client.connection.get(key, (err, data, response) => {
    var cells;
    if (response && response.statusCode === 204) {
      // result is successful but the scanner is exhausted, returns HTTP 204 status (no content)
      return callback();
    }
    if (err) {
      return callback(err);
    }
    cells = [];
    data.Row.forEach((row) => {
      key = utils.base64.decode(row.key, this.client.options.encoding);
      return row.Cell.forEach((cell) => {
        data = {};
        data.key = key;
        data.column = utils.base64.decode(cell.column, this.client.options.encoding);
        data.timestamp = cell.timestamp;
        data.$ = utils.base64.decode(cell.$, this.client.options.encoding);
        return cells.push(data);
      });
    });
    return callback(null, cells);
  });
};

// ## `scanner.delete(callback)`

// Internal method to unregister the scanner from the HBase server.
Scanner.prototype.delete = function(callback) {
  return this.client.connection.delete(`/${this.options.table}/scanner/${this.options.id}`, callback);
};

// ## `scanner._read(size)`

// Implementation of the `stream.Readable` API.
Scanner.prototype._read = function(size) {
  var handler;
  if (this.done) {
    return;
  }
  if (this.initializing) {
    return;
  }
  if (this.fetching) {
    return;
  }
  if (!this.options.id) {
    this.initializing = true;
    return this.init((err, id) => {
      this.initializing = false;
      if (err) {
        return this.emit('error', err);
      }
      return this._read();
    });
  }
  this.fetching = true;
  handler = (err, cells) => {
    var cell, j, len, more;
    if (this.done) {
      return;
    }
    if (err) {
      return this.emit('error', err);
    }
    if (!cells) {
      this.done = true;
      return this.delete((err) => {
        if (err) {
          return this.emit('error', err);
        }
        this.push(null);
        return this.fetching = false;
      });
    }
    more = true;
    for (j = 0, len = cells.length; j < len; j++) {
      cell = cells[j];
      if (!this.push(cell)) {
        more = false;
      }
    }
    if (more) {
      return this.get(handler);
    } else {
      return this.fetching = false;
    }
  };
  return this.get(handler);
};

module.exports = Scanner;
